SpringBoot
Напишем программу "Шутки"
- Грузит шутки про Чака Норриса
- Сохраняет их в БД
Как много нужно сделать?
- Указать все нужные зависимости
- Создать нужные бины
- Разработать интерфейс
- Подключиться к БД
- Натстроить библиотеку логирования

Spring Boot
- появление микросервисов потребовало ускорить создание проектов на Spring
- Так появился Spring Boot 1.0 в апреле 2014

В чем отличие от Spring(Core)?
для этого надо ответить на вопрос - для чего вообще нужен Spring?
- Меньше шаблонного инфраструктурного кода в сравнении с программой просто на Java.
Следовательно из этого меньше ошибок в коде.

В чем отличие Spring Boot от Spring?
- Меньше инфраструктурного кода Spring
- Концентрация на бизнес-логике, а не на конфигурации приложения!
------------------------------------------------------------------------------------------------------------------------
Шаги
- Инициализация проекта
- Сервис получения шуток
- Интерфейс пользователя
- Сервис работы с данными
- Логирование
------------------------------------------------------------------------------------------------------------------------
Инициализация проекта
команда Spring Boot'а сделала такую классную штуку, которая упращает данный этап - Spring Initializer
ссылка на сайт (https://start.spring.io/)

H2 DateBase-самая простая Java библиотека которая как раз таки выходит в виде зависимости. ТЕ мы можем ее подключить
к нашему проекту и получить простую СУБД в нем.
------------------------------------------------------------------------------------------------------------------------
Добавить сервис получения шуток
- Создать интерфейс JokeService
- Создать имплементацию с помощью RestTemplate
- Проверить!

Приступим:
1. Интерфейс-получение шуток у него будет всего один метод и он будет давать строку!
public interface JokeService{
  String getJoke();
}

2. Пишем имплементацию.Использовать RestTemplate
Делаем implement interface нашего интерфейса и наш класс помечаем аннотацие @Service те он будет выполнять бизнес-логику
@Service
public class JokeServiceRestImpl implements JokeService {
    @Override
    public String getJoke() {
        return null;
    }
}
Создаем Bean в нашем основном приложении тк SpringBootApplication он включает в себе аннотацию @Configuration
те все наше приложение является конфигурацией на данном этапе.
@Bean
	public RestTemplate getResTemplate(){
		return new RestTemplate();//возвращаем сконфигурированный объект с типом RestTemplate
}
Никак дополнительно конфигурировать его не будем считаем, что так коректнее

- Запускаем наш тест еще раз
contains -Возвращает true тогда и только тогда, когда эта строка содержит указанную последовательность значений char.
          Параметры:
          s - последовательность для поиска
          Возврат:
          истина, если эта строка содержит s, ложь иначе
Получили строку в тесте с нашего сервера. RestTemplate умеет каким то образом превращать ответы которые мы получаем
с сервера в какие то бизнесовые объекты.Таким образом мы сейчас получили объект String. Но мы можем и сами написать свои
типы и так же смапить их и так же получится наш объект из вот таких ответов сервера.
Мы должны определить собственный класс для данного типа ответа. У нас будет даже два класса. Обычно такие класс мы называем
очень просто, мы их называем DTO(транспортные объекты) --> наши классы JokeDTO & ValueDTO.

-- теперь идем обратно в нашу имплментацию JokeServiceRestImpl и говорим, что хотим получить ответ не в виде объекта
String а в виде JokeDTO:
@Override
    public String getJoke() {
        ResponseEntity<String> stringResponseEntity = //String-->JokeDTO
                restTemplate.getForEntity(URL, String.class); // String-->JokeDTO

        return stringResponseEntity.getBody();//должен возвращать строку:получаем Value->получаем шутку
        //getBody()-Возвращает тело этой сущности.
    }
-- Все сработало. получили одну строку!
теперь вопрос: Можно ли приложение отдать конечному пользователю?
ну если все наши пользователи были разработчиками Java и умели пользоваться тестами то мы могли быотдать:))
--> следовательно нужен какой то пользовательский интерфейс!
пользовательским интерфейсом будет командная строка!
My name is Shell.Spring Shell.
-Общаемся с пользователем через интерфейс командной строки
-Проект (зависимость)Spring Shell-позволяет нам уйти от обработки ввода и работать только с командами.
Для этого надо подключить зависимость
dependencies {
	compile
	group: 'org.springframework.shell',
	name: 'spring-shell-starter',
}
-- добавили implementation 'org.springframework.shell:spring-shell-starter:2.0.1.RELEASE'
- Теперь нам надо добавить свои команды:
@ShellComponent//это тот же самы компонент только он говорит Spring-context'у что это имеено компонент Shell'а
public class ShellCommands{
   private final JokeService jokeService;
   private String lastJoke;

   @ShellMethod("Get joke about Chuck Norris.")//небольшое описание для пользователя
   public String joke(){ //будет одна команда дай мне шутку
   lastJoke = jokeService.getJoke();
   return lastJoke;
   }
}
-- сделали тепрь проверим будет ли у нас все работать уже без тестов
-- запустим тест и у нас на время появится наш shell и выкинет ошибку
Почему так? они вызывают ошибку тк тест при запуске будет ждать ввод от пользователя и тест заисает!
Что мы можем с этим сделать?
тест не запускается из-за Shell.Как исправить?
Добавляем следующие строки(рецептик)
@RunWith(SpringRunner.class)//testImplementation 'org.springframework.boot:spring-boot-starter-test'
@SpringBootTest(
    properties = {
    InteractiveShellApplicationRunner.SPRING_SHELL_INTERACTIVE_ENABLED + "=FALSE",
  ScriptShellApplicationRunner
    .SPRING_SHELL_SCRIPT_ENABLED + "=FALSE"
    })
class JokeServiceRestImplTest {
// ...
}
------------------------------------------------------------------------------------------------------------------------
2.Добавляем работу с данными
- Добавить интерфейс JokeDataService.

как реализовать?
-- Подключить dependency
-- Использовать JDBCTemplate
ВСЕ ОСТАЛЬНОЕ СДЕЛАЕТ Spring Boot!
Но как он это делает?
1.@SpringBootApplication
2.@EnableAutoConfiguration
3.@Import(EnableAutoConfigurationImportSelector.class)
4.spring.factories //в библиотеках спринга starter так же входят такие файлики, которые называются spring.factories
в этих файликах spring.factories находятся названия и маски классов которые Spring Boot должен автоматически в себя включить

jrg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
jrg.springframework.boot.autoconfigure.jdc.DataSourceAutoConfiguration,\
jrg.springframework.boot.autoconfigure.jdc.JdbcTemplateAutoConfiguration,\

@Configuration
@ConditionalOnClass(ObjectMapper.class)
public class JacksonAutoConfiguration{
@Bean
public JsonComponentModule jsonComponentModule(){
return new JsonComponentModule();
}
}

-- Мы говорили у нас есть некое приложения которое обернуто некой анотацией @SpringBootApplication
@SpringBootApplication-->@EnableAutoConfiguration-->@Import(AutoConfigurationImportSelector.class)
@Import(AutoConfigurationImportSelector.class)-импорт некоторого класса который называется AutoConfigurationImportSelector
Что этот класс на самом деле делает?
-он пытается импортировать, загрузить в наш проект некоторые конфигурации, которые называются автоконфигурации.
Это как раз таки те конфигурации, которые содержат все те зависимости, которые мы можем использовать.Которые мы должны
писать руками но Spring Boot делает это за нас, как он эти автоконфигурации загружает?
Можно было бы предположить что он ищет классы по названию где в конце написано AutoConfiguration, потому что все классы
автоконфигурации они так и называются! -Но это предположение на самом деле неверное! в библиотеках спринга starter так
же входят такие файлики, которые называются spring.factories в этих файликах spring.factories находятся названия и маски
классов которые Spring Boot должен автоматически в себя включить.
-Что Spring делает дальше с этими знаниями?
-- Он загружает данный класс, но предположим что вот мы просто установили у себя Spring Boot внутри него уже огромное
количество автоконфигураций есть.Неужели все это наше небольшое приложение, которое работает только с shell загрузит
огромное количество бинов, потратит огромное количество оперативной памяти просто в пустую?
-на самом деле нет! тут есть очень важная особенность spring'а - аннотация @Conditional но в данном случае - @ConditionalOnClass
@ConditionalOnClass - говорит если в нашем класс path(те у нас есть какая то внешняя зависимость) класс ObjectMapper
тогда и только тогда эта авто конфигурация войдет в контекс нашего приложения. Соответственно если этого класса нет
данная авто конфигурация не будет загружена в момент запуска нашего приложения.

ПРАВИЛА ВЫБОРА:
- Пользовательские бины важнее автоматики
- Если есть зависимость в classpath, то Spring Boot попробует автоматически создать бин
!!Если наш бин не создается, то вы можете запустить Spring в режиме debug и получить отчет об автоконфигурации
(java -jar jokes.jar --debug) либо указав в настройках запуска в IDE(enable debug output) либо настройки запуска приложения
и в program arguments добавить ключ --debug.
------------------------------------------------------------------------------------------------------------------------
Работа с данными
- Создать интерфейс JokeDataService(далее создать его имплементацию)
- Создать имплементацию с помощью JdbcTemplate(использовать этот класс которые включает в себя некоторый шаблонный код)
- Добавить команды shell(и тк у нас уже есть пользовательский интерфейс добавить свои команды в shell)

- Мы создали наши запросы к БД. но не все условия мы выполнили-мы не обработали никак результат.
те мы получаем какой то объект RowMapper и он каким то образом должен превратиться в List.
каким образом он будет это делать?
- для начала поговорим что такое вообще RowMapper?
это еще одна особенность java8 которая называется функциональный интерфейс.
в java7 мы должны были сделать следующее: Мы должны были реализовать данный интерфейс-написать для него имплементацию
в java8 просто воспользуемся лямбдой

--готово!

- Дальше добавим наши команды!
переходим в класс shell и добавляем парочку новых!

Каким образом мы можем развернуть список строк просто в строку?
 @ShellMethod("List of all saved Joke")
    public String showSavedJoke() {
        jokeDataService.findAll().stream().collect(Collectors.joining(System.lineSeparator()));
        наш сервис.просим получить.превращаем в поток.собираем результат(собираем в строку(с разделителем пробел))
    }
    Будет ли работать?
    -нет. тк у нас нет еще таблицы.
- Как создать таблицу?
-- у нас запускается приложение мы должны выаолнить перед запуском приложения какие то дейтсвия
для это есть механизм. Лучшее место для постконстракта само наше приложение
@PostConstruct
    private void createJokesTable(){

    }

--Все работает почти так как надо!
но когда мы перезапускаем приложение не отображаются сохраненные шутки!
В чем проблема?
База данных H2 она изначально предполагается что она memory DataBase, те когда она поднимается вместе с нашим приложением
она поднимает нашу базу данных в памяти как только наше приложение завершается память освобождается и все что она там
насохраняла освобождается.

--Чтобы это исправить мы сделаем наше приложение лучше!
-Добавить хранение в файле
-Воспользоваться консолью h2
-Добавить логирование

Для начала займемся доконфигурацией нашего приложения! конфигурировать Spring Boot приложение можно двумя разными способами:
1.Можем написать нужные бины (автоматика хорошо, но если переопределяем своими бинами то наши бины перезатрут то
что было в автомате, соответственно можем создать наши бины с нужными конфигурациями)
2.Есть еще один путь-намного лучше!Мы прото можем написать настройки в специальном файле. там мы пишем где бы мы хотели
чтобы хранилась наша база данных. Для этих настроек уже существует отдельный файлик который называется application.properties.
--готово. проверим,будет ли работать?
-работает

-- что такое консоль h2?
это целая микростудия для работы с нашей БД:
1.запускаем наше приложение
2.переходим по этой ссылки http://localhost:8080/h2-console
3.там будет небольшой экранчик для того чтобы войти
4.в этой строчке JDBC URL: указываем наш путь из application.properties
5.SELECT * FROM JOKES и смотрим какие шутки сохраняли

--Теперь добавим логирование!
Что для этого нужно?
-Впринципе в Spring Boot все уже есть, но нужно добавить пару настроек в приложении
например: какие логи какие сообщения мы можем смотреть?
Что такое вообще логгирование?
-до этого мы логировали наши приложения (Через System.out) и думали все клево!Но это не так. на самом деле на уровне
промышленного приложения такой подход не катит. Нам нужно создавать нормальные логгеры и писать нормальные логи.
-У каждого такого log-сообщения как правило есть какой то уровень. Что произошло и на каком уровне.
всего таких уровней несколько
1.уровень DEBUG
2.TRACE что вообще выполняет приложение
3.INFO для пользователя
4.WARNING что то в нашем приложении пошло не так - не совсем ошибка но уже осторожение
5.ERROR малое количество информации только ошибки

Как объявить логгер в классе?
public class RestJokeRetriever{ //в моем приложении он назван иначе...
private final Logger logger =
LoggerFactory.getLogger(RestJokeRetriever.class);//создаем логгер для нашего класса
}
запустим наш тест а из теста уберем вывод на экран и увидим что у нас появилась доп информация

- донастроим наше приложение
logging.level.root=WARN
logging.level.com.gerasimov.springbootSpringBootProject=DEBUG //можем получать только информацию DEBUG-->INFO
logging.file.name=jokes.log //если что то случится первым делом мы побежим в этот файл!
------------------------------------------------------------------------------------------------------------------------
Итоги:
как сделать лучше?
-RestApi(SpringWeb)
Чтобы был пользовательский интерфейс

-JPA и Spring Data(ORM)
Добавить магии. Мы работали с JdbcTemplate но когда у нас одна две таблицы хорошо
а для больших проектов он надоест
ORM помомагает с этим

-LiquiBase
Для обновления в данных

-PostgresSQL
работать с h2 весело но для больших проектов не очень!

-SpringBoot Actuator
очень важно поддерживать приложение в работоспособном состоянии для этого есть такое понятие Метрики
и подключив такой проект как SpringBoot Actuator мы можем получить метрики из коробки - и узнать как работает наше приложение






